use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};
use warp::{reject, reply::json, Rejection, Reply};

use crate::error::AppError;
use crate::middleware::AuthContext;
use crate::models::{EpisodeAction, EpisodeActionQuery};
use crate::state::AppState;

#[derive(Debug, Deserialize)]
pub struct EpisodeActionQueryParams {
    pub since: Option<i64>,
    pub podcast: Option<String>,
    pub device: Option<String>,
    pub aggregated: Option<bool>,
}

#[derive(Debug, Serialize)]
pub struct EpisodeActionResponse {
    pub podcast: String,
    pub episode: String,
    pub action: String,
    pub timestamp: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub started: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub position: Option<i64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total: Option<i64>,
    pub device: String,
}

#[derive(Debug, Serialize)]
pub struct EpisodeActionsResult {
    pub actions: Vec<EpisodeActionResponse>,
    pub timestamp: i64,
}

pub async fn get_episode_actions(
    username: String,
    auth: AuthContext,
    params: EpisodeActionQueryParams,
    state: AppState,
) -> Result<impl Reply, Rejection> {
    if username != auth.username {
        return Err(reject::custom(AppError::Authorization));
    }

    let query = EpisodeActionQuery {
        since: params.since,
        podcast: params.podcast.clone(),
        device: params.device.clone(),
        aggregated: params.aggregated,
    };

    let actions = state
        .episode_action_service
        .get_episode_actions(auth.user_id, query)
        .await
        .map_err(|e| reject::custom(AppError::Internal(e.to_string())))?;

    let current_timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs() as i64;

    let response_actions: Vec<EpisodeActionResponse> = actions
        .into_iter()
        .map(|action| EpisodeActionResponse {
            podcast: action.podcast_url,
            episode: action.episode_url,
            action: action.action,
            timestamp: action.timestamp,
            started: action.started,
            position: action.position,
            total: action.total,
            device: action.device,
        })
        .collect();

    let result = EpisodeActionsResult {
        actions: response_actions,
        timestamp: current_timestamp,
    };

    Ok(json(&result))
}

#[derive(Debug, Deserialize)]
pub struct EpisodeActionUpload {
    pub podcast: String,
    pub episode: String,
    pub device: String,
    pub action: String,
    pub timestamp: i64,
    pub started: Option<i64>,
    pub position: Option<i64>,
    pub total: Option<i64>,
}

pub async fn upload_episode_actions(
    username: String,
    auth: AuthContext,
    state: AppState,
    actions: Vec<EpisodeActionUpload>,
) -> Result<impl Reply, Rejection> {
    if username != auth.username {
        return Err(warp::reject::custom(crate::error::AppError::Authorization));
    }

    let mut resolved_actions = Vec::new();
    let mut all_update_urls = Vec::new();

    // Resolve device strings to device IDs, creating devices if needed
    for action in actions {
        // Sanitize URLs
        let sanitized_podcast = crate::utils::sanitize_url(&action.podcast);
        let sanitized_episode = crate::utils::sanitize_url(&action.episode);

        // Track URL changes
        if action.podcast != sanitized_podcast {
            all_update_urls.push([action.podcast.clone(), sanitized_podcast.clone()]);
        }
        if action.episode != sanitized_episode {
            all_update_urls.push([action.episode.clone(), sanitized_episode.clone()]);
        }

        // Get or create device
        let device_db_id = state
            .device_service
            .get_or_create_device(auth.user_id, &action.device, None, None)
            .await
            .map_err(|e| warp::reject::custom(AppError::Internal(e.to_string())))?;

        resolved_actions.push(EpisodeAction {
            id: 0, // Will be auto-generated by database
            user_id: auth.user_id,
            device_id: device_db_id,
            podcast_url: sanitized_podcast,
            episode_url: sanitized_episode,
            action: action.action,
            timestamp: action.timestamp,
            started: action.started,
            position: action.position,
            total: action.total,
            created_at: 0, // Will be set by database
        });
    }

    state
        .episode_action_service
        .upload_episode_actions(resolved_actions)
        .await
        .map_err(warp::reject::custom)?;

    Ok(json(&serde_json::json!({
        "update_urls": all_update_urls,
    })))
}
